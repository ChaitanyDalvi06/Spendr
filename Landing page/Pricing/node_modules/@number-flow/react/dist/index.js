"use strict";
"use client";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  NumberFlowElement: () => NumberFlowElement,
  default: () => src_default,
  useCanAnimate: () => useCanAnimate
});
module.exports = __toCommonJS(src_exports);
var React = __toESM(require("react"));
var import_number_flow = require("number-flow");
var isReact19 = React.version.startsWith("19.");
var OBSERVED_ATTRIBUTES = ["parts"];
var NumberFlowElement = class extends import_number_flow.NumberFlowLite {
  attributeChangedCallback(attr, _oldValue, newValue) {
    this[attr] = JSON.parse(newValue);
  }
};
NumberFlowElement.observedAttributes = OBSERVED_ATTRIBUTES;
NumberFlowElement.define();
var formatters = {};
var serializeParts = isReact19 ? (p) => p : JSON.stringify;
function splitProps(props) {
  const {
    transformTiming,
    spinTiming,
    opacityTiming,
    animated,
    respectMotionPreference,
    trend,
    continuous,
    ...rest
  } = props;
  return [
    {
      transformTiming,
      spinTiming,
      opacityTiming,
      animated,
      respectMotionPreference,
      trend,
      continuous
    },
    rest
  ];
}
var _el;
var NumberFlowImpl = class extends React.Component {
  constructor(props) {
    super(props);
    __privateAdd(this, _el);
    this.handleRef = this.handleRef.bind(this);
  }
  // Update the non-`parts` props to avoid JSON serialization
  // Parts needs to be set in render still:
  updateNonPartsProps(prevProps) {
    if (!__privateGet(this, _el)) return;
    __privateGet(this, _el).manual = !this.props.isolate;
    const [nonParts] = splitProps(this.props);
    Object.assign(
      __privateGet(this, _el),
      Object.fromEntries(Object.entries(nonParts).filter(([_, v]) => v != null))
    );
    if (prevProps?.onAnimationsStart)
      __privateGet(this, _el).removeEventListener("animationsstart", prevProps.onAnimationsStart);
    if (this.props.onAnimationsStart)
      __privateGet(this, _el).addEventListener("animationsstart", this.props.onAnimationsStart);
    if (prevProps?.onAnimationsFinish)
      __privateGet(this, _el).removeEventListener("animationsfinish", prevProps.onAnimationsFinish);
    if (this.props.onAnimationsFinish)
      __privateGet(this, _el).addEventListener("animationsfinish", this.props.onAnimationsFinish);
  }
  componentDidMount() {
    this.updateNonPartsProps();
    if (isReact19 && __privateGet(this, _el)) {
      __privateGet(this, _el).parts = this.props.parts;
    }
  }
  getSnapshotBeforeUpdate(prevProps) {
    this.updateNonPartsProps(prevProps);
    if (this.props.isolate || this.props.animated === false || prevProps.parts === this.props.parts)
      return false;
    __privateGet(this, _el)?.willUpdate();
    return true;
  }
  componentDidUpdate(_, __, snapshot) {
    if (snapshot) __privateGet(this, _el)?.didUpdate();
  }
  handleRef(el) {
    if (this.props.innerRef) this.props.innerRef.current = el;
    __privateSet(this, _el, el);
  }
  render() {
    const [_, { innerRef, className, parts, willChange, isolate, ...rest }] = splitProps(this.props);
    return (
      // @ts-expect-error missing types
      /* @__PURE__ */ React.createElement(
        "number-flow",
        {
          ref: this.handleRef,
          "data-will-change": willChange ? "" : void 0,
          class: className,
          ...rest,
          dangerouslySetInnerHTML: { __html: (0, import_number_flow.render)({ formatted: parts.formatted, willChange }) },
          parts: serializeParts(parts)
        }
      )
    );
  }
};
_el = new WeakMap();
var NumberFlow = React.forwardRef(function NumberFlow2({ value, locales, format, ...props }, _ref) {
  React.useImperativeHandle(_ref, () => ref.current, []);
  const ref = React.useRef();
  const localesString = React.useMemo(() => locales ? JSON.stringify(locales) : "", [locales]);
  const formatString = React.useMemo(() => format ? JSON.stringify(format) : "", [format]);
  const parts = React.useMemo(() => {
    const formatter = formatters[`${localesString}:${formatString}`] ??= new Intl.NumberFormat(
      locales,
      format
    );
    return (0, import_number_flow.partitionParts)(value, formatter);
  }, [value, localesString, formatString]);
  return /* @__PURE__ */ React.createElement(NumberFlowImpl, { ...props, parts, innerRef: ref });
});
var src_default = NumberFlow;
function useCanAnimate({ respectMotionPreference = true } = {}) {
  const [canAnimate, setCanAnimate] = React.useState(import_number_flow.canAnimate);
  const [reducedMotion, setReducedMotion] = React.useState(false);
  React.useEffect(() => {
    setCanAnimate(import_number_flow.canAnimate);
    setReducedMotion(import_number_flow.prefersReducedMotion?.matches ?? false);
  }, []);
  React.useEffect(() => {
    if (!respectMotionPreference) return;
    const onChange = ({ matches }) => {
      setReducedMotion(matches);
    };
    import_number_flow.prefersReducedMotion?.addEventListener("change", onChange);
    return () => {
      import_number_flow.prefersReducedMotion?.removeEventListener("change", onChange);
    };
  }, [respectMotionPreference]);
  return canAnimate && (!respectMotionPreference || !reducedMotion);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NumberFlowElement,
  useCanAnimate
});
