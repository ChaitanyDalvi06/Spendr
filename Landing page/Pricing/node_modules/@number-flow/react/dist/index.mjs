"use client";
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/index.tsx
import * as React from "react";
import {
  render,
  partitionParts,
  NumberFlowLite,
  prefersReducedMotion,
  canAnimate as _canAnimate
} from "number-flow";
var isReact19 = React.version.startsWith("19.");
var OBSERVED_ATTRIBUTES = ["parts"];
var NumberFlowElement = class extends NumberFlowLite {
  attributeChangedCallback(attr, _oldValue, newValue) {
    this[attr] = JSON.parse(newValue);
  }
};
NumberFlowElement.observedAttributes = OBSERVED_ATTRIBUTES;
NumberFlowElement.define();
var formatters = {};
var serializeParts = isReact19 ? (p) => p : JSON.stringify;
function splitProps(props) {
  const {
    transformTiming,
    spinTiming,
    opacityTiming,
    animated,
    respectMotionPreference,
    trend,
    continuous,
    ...rest
  } = props;
  return [
    {
      transformTiming,
      spinTiming,
      opacityTiming,
      animated,
      respectMotionPreference,
      trend,
      continuous
    },
    rest
  ];
}
var _el;
var NumberFlowImpl = class extends React.Component {
  constructor(props) {
    super(props);
    __privateAdd(this, _el);
    this.handleRef = this.handleRef.bind(this);
  }
  // Update the non-`parts` props to avoid JSON serialization
  // Parts needs to be set in render still:
  updateNonPartsProps(prevProps) {
    if (!__privateGet(this, _el)) return;
    __privateGet(this, _el).manual = !this.props.isolate;
    const [nonParts] = splitProps(this.props);
    Object.assign(
      __privateGet(this, _el),
      Object.fromEntries(Object.entries(nonParts).filter(([_, v]) => v != null))
    );
    if (prevProps?.onAnimationsStart)
      __privateGet(this, _el).removeEventListener("animationsstart", prevProps.onAnimationsStart);
    if (this.props.onAnimationsStart)
      __privateGet(this, _el).addEventListener("animationsstart", this.props.onAnimationsStart);
    if (prevProps?.onAnimationsFinish)
      __privateGet(this, _el).removeEventListener("animationsfinish", prevProps.onAnimationsFinish);
    if (this.props.onAnimationsFinish)
      __privateGet(this, _el).addEventListener("animationsfinish", this.props.onAnimationsFinish);
  }
  componentDidMount() {
    this.updateNonPartsProps();
    if (isReact19 && __privateGet(this, _el)) {
      __privateGet(this, _el).parts = this.props.parts;
    }
  }
  getSnapshotBeforeUpdate(prevProps) {
    this.updateNonPartsProps(prevProps);
    if (this.props.isolate || this.props.animated === false || prevProps.parts === this.props.parts)
      return false;
    __privateGet(this, _el)?.willUpdate();
    return true;
  }
  componentDidUpdate(_, __, snapshot) {
    if (snapshot) __privateGet(this, _el)?.didUpdate();
  }
  handleRef(el) {
    if (this.props.innerRef) this.props.innerRef.current = el;
    __privateSet(this, _el, el);
  }
  render() {
    const [_, { innerRef, className, parts, willChange, isolate, ...rest }] = splitProps(this.props);
    return (
      // @ts-expect-error missing types
      /* @__PURE__ */ React.createElement(
        "number-flow",
        {
          ref: this.handleRef,
          "data-will-change": willChange ? "" : void 0,
          class: className,
          ...rest,
          dangerouslySetInnerHTML: { __html: render({ formatted: parts.formatted, willChange }) },
          parts: serializeParts(parts)
        }
      )
    );
  }
};
_el = new WeakMap();
var NumberFlow = React.forwardRef(function NumberFlow2({ value, locales, format, ...props }, _ref) {
  React.useImperativeHandle(_ref, () => ref.current, []);
  const ref = React.useRef();
  const localesString = React.useMemo(() => locales ? JSON.stringify(locales) : "", [locales]);
  const formatString = React.useMemo(() => format ? JSON.stringify(format) : "", [format]);
  const parts = React.useMemo(() => {
    const formatter = formatters[`${localesString}:${formatString}`] ??= new Intl.NumberFormat(
      locales,
      format
    );
    return partitionParts(value, formatter);
  }, [value, localesString, formatString]);
  return /* @__PURE__ */ React.createElement(NumberFlowImpl, { ...props, parts, innerRef: ref });
});
var src_default = NumberFlow;
function useCanAnimate({ respectMotionPreference = true } = {}) {
  const [canAnimate, setCanAnimate] = React.useState(_canAnimate);
  const [reducedMotion, setReducedMotion] = React.useState(false);
  React.useEffect(() => {
    setCanAnimate(_canAnimate);
    setReducedMotion(prefersReducedMotion?.matches ?? false);
  }, []);
  React.useEffect(() => {
    if (!respectMotionPreference) return;
    const onChange = ({ matches }) => {
      setReducedMotion(matches);
    };
    prefersReducedMotion?.addEventListener("change", onChange);
    return () => {
      prefersReducedMotion?.removeEventListener("change", onChange);
    };
  }, [respectMotionPreference]);
  return canAnimate && (!respectMotionPreference || !reducedMotion);
}
export {
  NumberFlowElement,
  src_default as default,
  useCanAnimate
};
